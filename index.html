<html>
	<head>
    <link rel="stylesheet" type="text/css" href="semantic/semantic.min.css">
    <script
        src="https://code.jquery.com/jquery-3.1.1.min.js"
        integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
        crossorigin="anonymous"></script>
    <script src="semantic/semantic.min.js"></script>
    <title>Team 52 - Final Status Report</title>
	</head>
	<body>
    <div class="ui container">
      <div class="ui center aligned container">
        <br>
        <h1>Alternate Subdivision Schemes</h1>
        <h3>Final Status Report</h3>
      </div>

      <h2>Team Members (Team 52)</h2>
      <ul>
        <li>Jason Wang (jasonwang8@berkeley.edu)</li>
        <li>Julia Nicholson (julianicholson@berkeley.edu)</li>
        <li>Zaid Mamsa (zaid.mamsa@berkeley.edu)</li>
        <li>Xiaoyuan Zhu (m195@berkeley.edu)</li>
      </ul>

      <h2>Summary</h2>
      <p>
        In this project, we have explored and implemented additional subdivision schemes: the Butterfly scheme, the
        modified Butterfly scheme, Catmull-Clark scheme, Doo-Sabin scheme, and the polar subdivision scheme, etc. We
        will compare the pros and cons for each of them, and discuss the tradeoffs when choosing a subdivision scheme
        under different scenarios.
      </p>

      <h2>Presentation Slides</h2>
      <p>
        Please find our presentation slides here:
        <a href="https://docs.google.com/presentation/d/1QyphpPdMwIYgVYDXgp8ylveiFAjEe0J43HWO5qeNjXY/edit?usp=sharing" target="_blank">
          <b>Alternate Subdivision Schemes Presentation</b>.
        </a>
      </p>
<!--      <h2>Milestone Video</h2>-->
<!--      <div style="position:relative;width:fit-content;height:fit-content;">-->
<!--        <a style="position:absolute;top:20px;right:1rem;opacity:0.8;" href="https://clipchamp.com/watch/s9mPxmny3IA?utm_source=embed&utm_medium=embed&utm_campaign=watch">-->
<!--          <img style="height:22px;" src="https://clipchamp.com/e.svg" alt="Made with Clipchamp" />-->
<!--        </a>-->
<!--        <iframe allow="autoplay;" allowfullscreen style="border:none" src="https://clipchamp.com/watch/s9mPxmny3IA/embed" width="640" height="360"></iframe>-->
<!--      </div>-->

      <h2>Technical Approach</h2>
      <h3>1. Infrastructure Improvements</h3>

      <h4>1.1 Command Line Flag "-a" to Switch between Subdivision Schemes</h4>
      <p>
        We cloned the code base of Project 2 to get started. But soon we found that the existing code infrastructure
        cannot satisfy our need for multiple subdivision schemes, because it is designed to only support Loop subdivision in
        Project 2. It's very inefficient to switch between different schemes.
      </p>
      <p>
        To overcome this limitation, we added a new flag <b>-a</b> to arguments to determine which subdivision scheme to
        use. For example, one can use command <b>./meshedit -a doo-sabin ../dae/teapot.dae</b> to run Doo-Sabin subdivision
        on scene file teapot.dae.
      </p>
      <p>
        This dramatically improved our efficiency when we work on different subdivision schemes in parallel. It also helps
        us have separation of concerns and make our code modular and more readable.
      </p>

      <h4>1.2 Duration Measurement for Subdivision Executions</h4>
      <p>
        We also added the logic to measure the duration of subdivision/upsampling duration, so that we can easily compare
        the performance difference between different schemes.
      </p>

      <h3>2. Butterfly Subdivision Scheme</h3>
      <p>
        The function <b>MeshResampler::upsampleButterfly( HalfedgeMesh& mesh )</b> implements the Butterfly method for
        subdivision. First, the function iterates through each edge in the mesh and computes the position of the vertex
        that will be added in the middle of that edge during subdivision. The position of this vertex is determined by
        nearby vertices, inspired by slide 65 of
        <a href="http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/10_Subdivision.pdf" target="_blank">
          http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/10_Subdivision.pdf
        </a>
        , where we chose omega to be ⅛. Similar to Loop subdivision, this new position is stored in
        edge->newPosition. After all these new positions have been computed, <b>upsampleButterfly(...)</b> iterates through the
        edges again and adds the new vertices with the new positions to the mesh.
      </p>
      <p>
        After the new vertices are created, the function needs to create edges between the new vertices, along with the
        corresponding new faces and halfedges. This is the most complicated part of the function, because when iterating
        through the new vertices, there are a few cases to account for: adjacent new vertices may have already been hit
        by the for loop, so some of the new edges, faces, and halfedges may have already been created. Before the
        function returns, it sets all the vertices’ isNew attributes to false.
      </p>
      <p>
        One challenge for the <b>upsampleButterfly(...)</b> was figuring out the order of computations and operations on the
        mesh. The desired subdivision product is simple: split each triangle into four triangles with new vertices
        determined by the positions of surrounding triangles (
        <a href="https://www3.cs.stonybrook.edu/~qin/research/mandal-tvcg2000.pdf" target="_blank">
          https://www3.cs.stonybrook.edu/~qin/research/mandal-tvcg2000.pdf
        </a>
        ). But creating and assigning the mesh elements correctly was more tedious and exacting. The major bugs we had
        were due to accessing a mesh element before it had been correctly assigned.
      </p>

      <h3>3. Doo-Sabin Subdivision Scheme</h3>
      <p>
        Our Doo-Sabin implementation is greatly inspired by article
        <a target="_blank" href="https://www.cs.unc.edu/~dm/UNC/COMP258/LECTURES/Doo-Sabin.pdf">
          https://www.cs.unc.edu/~dm/UNC/COMP258/LECTURES/Doo-Sabin.pdf
        </a>. To implement this scheme, we take 6 steps:
      </p>
      <ul>
        <li>
          Step 1: Calculate the average of all vertices in each face and put its position in the newly added
          <b>averagePosition</b> field in Face class.
        </li>
        <li>
          Step 2: Calculate the midpoint of each edge, and put its position in <b>newPosition</b> field in Edge class.
        </li>
        <li>
          Step 3 (Case 1 in below picture): Calculate the positions of new vertices using the positions calculated in
          step 1 and 2. For each
          old vertex, the position of the new vertex is the average of these 4 points: the old vertex, the midpoint of
          the two edges (generated in step 2), and the average face point (generated in step 1). And connect the new
          vertices in each face.
        </li>
        <li>
          Step 4 (Case 2 in below picture): Add the connections across old edges. For each old edge, we connect the 4
          new vertices (2 on each
          face), and form a face.
        </li>
        <li>
          Step 5 (Case 3 in below picture): Re-connect edges surrounding each old vertex.
        </li>
        <li>
          Step 6: Delete all old components (vertices, edges, faces, boundaries) in the mesh.
        </li>
      </ul>
      <div class="ui two column grid">
        <div class="row centered">
          <div class="six wide column ui segment">
            <img src="./assets/doo_original.png">
            <h5 class="ui center aligned container">Original Mesh with Calculated New Vertices</h5>
          </div>
          <div class="ten wide column ui segment">
            <img src="./assets/doo_subdivision.png">
            <h5 class="ui center aligned container">Upsampled Mesh with Doo-Sabin Scheme in Different Cases</h5>
          </div>
        </div>
      </div>

      <h2>Results</h2>
      <h2>References</h2>
      <ul>
        <li>
          <a target="_blank" href="http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/10_Subdivision.pdf">
            http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/10_Subdivision.pdf
          </a>
        </li>
        <li>
          <a target="_blank" href="https://www3.cs.stonybrook.edu/~qin/research/mandal-tvcg2000.pdf">
            https://www3.cs.stonybrook.edu/~qin/research/mandal-tvcg2000.pdf
          </a>
        </li>
        <li>
          <a target="_blank" href="https://www.researchgate.net/figure/Butterfly-subdivision-a-Butterfly-structure-and-weights-b-Position-of-newly-added_fig3_3308801">
            https://www.researchgate.net/figure/Butterfly-subdivision-a-Butterfly-structure-and-weights-b-Position-of-newly-added_fig3_3308801
          </a>
        </li>
        <li>
          <a target="_blank" href="https://www.cs.unc.edu/~dm/UNC/COMP258/LECTURES/Doo-Sabin.pdf">
            https://www.cs.unc.edu/~dm/UNC/COMP258/LECTURES/Doo-Sabin.pdf
          </a>
        </li>
      </ul>
      <h2>Contributions</h2>
      <p>
        Julia implemented the Butterfly subdivision. Maggie implemented Doo-Sabin subdivision. Maggie also added timing
        and flag functionality for comparing different subdivision schemes. Zaid implemented Catmull-Clark. Jason
        implemented Modified Butterfly. The deliverables such as presentation slides, video, and website were divided
        between the four of us.
      </p>
      <br>
    </div>
	</body>
</html>